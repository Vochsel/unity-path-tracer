// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define M_PI 3.14159265359f
//#define WIDTH 480
//#define HEIGHT 360
#define ASPECT WIDTH/HEIGHT
#define SAMPS 8

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Input;
RWTexture2D<float4> Result;

float camFOV;
float4x4 camToWorld;
float4x4 worldToCam;

int WIDTH;
int HEIGHT;

float time;
float textureWeight;

struct Ray {
	float3 orig;
	float3 dir;
};

Ray MakeRay(float3 a_origin, float3 a_dir) 
{
	Ray r;
	r.orig = a_origin;
	r.dir = a_dir;
	return r;
}

struct ptMaterial
{
    float4 albedo, emission;
    float metallic, smoothness;
};

struct Sphere {
	float rad;
	float3 pos, emi, col;

	ptMaterial material;

	float intersect(inout Ray r, inout float depth)  {
		float3 op = pos - r.orig;    // distance from ray.orig to center sphere 
		float t, epsilon = 0.000000001f;  // epsilon required to prevent floating point precision artefacts
		float b = dot(op, r.dir);    // b in quadratic equation
		float disc = b*b - dot(op, op) + rad*rad;  // discriminant quadratic equation
		if (disc<0) return 0;       // if disc < 0, no real solution (we're not interested in complex roots) 
		else disc = sqrt(disc);    // if disc >= 0, check for solutions using negative and positive discriminant
		depth = disc * 2.0f;
		return (t = b - disc)>epsilon ? t : ((t = b + disc)>epsilon ? t : 0); // pick closest point in front of ray origin
	}
};

struct Triangle {
	float3 v0, v1, v2, normal;

	

	float intersect(inout Ray r, inout float t) {

		    float3 v0v1 = v1 - v0; 
			float3 v0v2 = v2 - v0; 
			float3 pvec = cross(r.dir, v0v2); 
			float det = dot(v0v1, pvec); 
			// if the determinant is negative the triangle is backfacing
			// if the determinant is close to 0, the ray misses the triangle
			if (det < 0.001f) return false; 
	 
			float invDet = 1 / det; 
 
			float3 tvec = r.orig - v0; 
			float u = dot(tvec, pvec) * invDet; 
			if (u < 0 || u > 1) return false; 
 
			float3 qvec = cross(tvec,v0v1); 
			float v = dot(r.dir, qvec) * invDet; 
			if (v < 0 || u + v > 1) return false; 
 
			t = dot(v0v2, qvec) * invDet; 
 
			return true; 

	/*	float u = 0.0f;
		float v = 0.0f;

    
		float kEpsilon = 0.0001f;


		float3 v0v1 = v1 - v0; 
		float3 v0v2 = v2 - v0; 
		float3 pvec = cross(r.dir, v0v2); 
		float det = dot(v0v1, pvec);
		if (det < kEpsilon) return false; 
		if (abs(det) < kEpsilon) return false; 

		float3 cop = camToWorld._m03_m13_m23;
	

		float3 norig = r.orig;
		float3 ndir = r.dir;

		float3 nv0 = v0;
		float3 nv1 = v1;
		float3 nv2 = v2;


		//float3 v0v1 = (v1 - v0); 
		//float3 v0v2 = (v2 - v0); 
		// no need to normalize
		float3 N = cross(v0v1, v0v2); // N 
		float denom = dot(N,N); 
 
		// Step 1: finding P
 
		// check if ray and plane are parallel ?
		float NdotRayDirection = dot(N, ndir); 
		if (abs(NdotRayDirection) < kEpsilon) // almost 0 
			return false; // they are parallel so they don't intersect ! 
 
		// compute d parameter using equation 2
		float d = dot(N, nv0); 
 
		// compute t (equation 3)
		//This was the place -_-
		t = (dot(N, v0 - r.orig)) / NdotRayDirection; 
		// check if the triangle is in behind the ray
		if (t < 0) return false; // the triangle is behind 
 
		// compute the intersection point using equation 1
		float3 P = norig + t * ndir; 
 
		// Step 2: inside-outside test
		float3 C; // vector perpendicular to triangle's plane 
 
		// edge 0
		float3 edge0 = nv1 - nv0; 
		float3 vp0 = P - nv0; 
		C = cross(edge0, vp0); 
		if (dot(N, C) < 0) return false; // P is on the right side 
 
		// edge 1
		float3 edge1 = nv2 - nv1; 
		float3 vp1 = P - nv1; 
		C = cross(edge1, vp1); 
		if ((u = dot(N, C)) < 0)  return false; // P is on the right side 
 
		// edge 2
		float3 edge2 = nv0 - nv2; 
		float3 vp2 = P - nv2; 
		C = cross(edge2, vp2); 
		if ((v = dot(N, C)) < 0) return false; // P is on the right side; 
 
		u /= denom; 
		v /= denom; 
 
		return true; // t*///his ray hits the triangle 
	
	}
};


/*struct Mesh {
	ptMaterial material;
	//Triangle tris[];
	int numTris
	float4x4 transform;
};*/


RWStructuredBuffer<Sphere> spheres;
RWStructuredBuffer<Triangle> triangleMesh;
//RWStructuredBuffer<Mesh> meshes;

bool intersect_scene(inout Ray r, inout float t, inout int id, inout float cdepth, inout int isTriangle) {

	float n = 6, d, inf = t = 1e20;  // t is distance to closest intersection, initialise t to a huge number outside scene
	float dd = 0.0f;
	
	for (int i = int(n); i--;) { // test all scene objects for intersection
		if ((d = spheres[i].intersect(r, dd)) && d < t) {  // if newly computed intersection distance d is smaller than current closest intersection distance
			t = d;  // keep track of distance along ray to closest intersection point 
			id = i; // and closest intersected object
			cdepth = dd;
			isTriangle = 0;
		}
	}
	uint numTris, stride;
	triangleMesh.GetDimensions(numTris, stride);
	for (int j = int(numTris); j--;) { // test all scene objects for intersection
		//float dd = 0.0f;
		if ((d = triangleMesh[j].intersect(r, dd)) && d < t) {  // if newly computed intersection distance d is smaller than current closest intersection distance
			t = d;  // keep track of distance along ray to closest intersection point 
			id = j; // and closest intersected object
			cdepth = dd;			
			isTriangle = 1;
		}
	}

//triangleMesh
	return t<inf; // returns true if an intersection with the scene occurred, false when no hit
}

static float getrandom(inout uint seed0, inout uint seed1) {
	seed0 = 36969 * ((seed0+ asuint(time)) & 65535) + ((seed0+ asuint(time)) >> 16);  // hash the seeds using bitwise AND and bitshifts
	seed1 = 18000 * ((seed1+ asuint(time)) & 65535) + ((seed1+ asuint(time)) >> 16);

	uint ires = ((seed0) << 16) + (seed1);

	uint ui = (ires & 0x007fffff) | 0x40000000;  // bitwise AND, bitwise OR
	float uf = asfloat(ui);

	return (uf - 2.f) / 2.f;
} 

float3 radiance(Ray r2, inout uint s1, inout uint s2) { // returns ray color

	float3 accucolor = float3(0.0f, 0.0f, 0.0f); // accumulates ray colour with each iteration through bounce loop
	float3 mask = float3(1.0f, 1.0f, 1.0f);

	Ray r;
	r.orig = r2.orig;
	r.dir = r2.dir;	

	// ray bounce loop (no Russian Roulette used) 
	for (int bounces = 0; bounces < 8; bounces++) {  // iteration up to 4 bounces (replaces recursion in CPU code)

		float t;           // distance to closest intersection 
		int id = 0;        // index of closest intersected sphere 

						   // test ray for intersection with scene
		float cdepth = 0.0f;
		int wasTriangle = -1;
		if (!intersect_scene(r, t, id, cdepth, wasTriangle))
			return float3(1.0f, 0.0f, 1.0f);

		if(wasTriangle == 1){
			Triangle tri = triangleMesh[id];
			float3 x = r.orig + r.dir*t;          // hitpoint 
			float3 n = tri.normal;    // normal
			float3 nl = dot(n, r.dir) < 0 ? n : n * -1; // front facing normal

			accucolor += mask * float3(0,0,0);

			// create 2 random numbers
			float r1 = 2 * M_PI * getrandom(s1, s2); // pick random number on unit circle (radius = 1, circumference = 2*Pi) for azimuth
			float r2 = getrandom(s1, s2);  // pick random number for elevation
			float r2s = sqrt(r2);

			// compute local orthonormal basis uvw at hitpoint to use for calculation random ray direction 
			// first vector = normal at hitpoint, second vector is orthogonal to first, third vector is orthogonal to first two vectors
			float3 w = nl;
			float3 u = normalize(cross((abs(w.x) > .1 ? float3(0, 1, 0) : float3(1, 0, 0)), w));
			float3 v = cross(w, u);

			// compute random ray direction on hemisphere using polar coordinates
			// cosine weighted importance sampling (favours ray directions closer to normal direction)
			float3 d = normalize(u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1 - r2));
			r.orig = x + nl*0.025f;

			r.dir = d;
				

			mask *= float3(0.9,0.9,0.9);

			//mask.x *= obj.col.x;    
			mask *= dot(d, nl);  // weigh light contribution using cosine of angle between incident light and normal
			mask *= 2;          // fudge factor	

		} else {
			Sphere obj = spheres[id];  // hitobject
			float3 x = r.orig + r.dir*t;          // hitpoint 
			float3 n = normalize(x - obj.pos);    // normal
			float3 nl = dot(n, r.dir) < 0 ? n : n * -1; // front facing normal

			accucolor += mask * obj.material.emission;
		
			// create 2 random numbers
			float r1 = 2 * M_PI * getrandom(s1, s2); // pick random number on unit circle (radius = 1, circumference = 2*Pi) for azimuth
			float r2 = getrandom(s1, s2);  // pick random number for elevation
			float r2s = sqrt(r2);

			// compute local orthonormal basis uvw at hitpoint to use for calculation random ray direction 
			// first vector = normal at hitpoint, second vector is orthogonal to first, third vector is orthogonal to first two vectors
			float3 w = nl;
			float3 u = normalize(cross((abs(w.x) > .1 ? float3(0, 1, 0) : float3(1, 0, 0)), w));
			float3 v = cross(w, u);

			// compute random ray direction on hemisphere using polar coordinates
			// cosine weighted importance sampling (favours ray directions closer to normal direction)
			float3 d = normalize(u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1 - r2));
			float3 reflDir = reflect(r.dir, n);
			r.orig = x + nl*0.025f;

			r.dir = lerp(d, reflDir, obj.material.metallic);
				

			mask *= obj.material.albedo;

			//mask.x *= obj.col.x;    
			mask *= dot(d, nl);  // weigh light contribution using cosine of angle between incident light and normal
			mask *= 2;          // fudge factor	
		}
	}

	return accucolor;
}

inline float clamp(float x) { return x < 0.0f ? 0.0f : x > 1.0f ? 1.0f : x; }

inline int toInt(float x) { return int(pow(clamp(x), 1 / 2.2) * 255 + .5); }  // convert RGB float in range [0,1] to int in range [0, 255] and perform gamma correction

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float2 resolution = float2 (WIDTH,HEIGHT);
    float2 coordinates = float2 (id.x,id.y);
    float2 p = (coordinates.xy/resolution.xy);

	uint x = coordinates.x;
	uint y = coordinates.y;	

	uint i = (HEIGHT - y - 1)*WIDTH + x; // index of current pixel (calculated using thread index) 

	uint s1 = x;  // seeds for random number generator
	uint s2 = y;

	float fov = camFOV * (M_PI / 180.0f);

	float2 co = p * 2.0 - 1.0;
	co.x *= (float)WIDTH / (float)HEIGHT;

	float3 r;  
	r = float3(0.0f, 0.0f, 0.0f); 

	float imgAspect = (float)WIDTH / (float)HEIGHT;
	float properFov = tan(camFOV / 2.0f * M_PI / 180.0f);
	float Px = (2.0f * ((x - 0.5) / WIDTH) - 1) * imgAspect;
	float Py = (1.0f - 2.0f * ((y - 0.5) / HEIGHT) );

	float4 d = normalize(float4(Px, -Py, -1, 0));	

	float3 cop = camToWorld._m03_m13_m23;
	float3 cdp = normalize(mul(camToWorld, d).xyz).xyz;

	for (int s = 0; s < SAMPS; s++) { 
		r = r + radiance(MakeRay(cop, cdp), s1, s2)*(1. / SAMPS);  		
	}

	float4 outt = float4(clamp(r.x, 0.0f, 1.0f), clamp(r.y, 0.0f, 1.0f), clamp(r.z, 0.0f, 1.0f), 1.0);
	
	float v = ((r.x + r.y + r.z) / 3.0);

	Result[id.xy] = lerp(outt, Input[id.xy], textureWeight);
}
