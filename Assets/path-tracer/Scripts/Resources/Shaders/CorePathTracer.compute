// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define M_PI 3.14159265359f
//#define WIDTH 480
//#define HEIGHT 360
#define ASPECT WIDTH/HEIGHT
#define SAMPS 1
#define EPSILON 0.0001f

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Input;
RWTexture2D<float4> Result;

float camFOV;
float4x4 camToWorld;
float4x4 worldToCam;

int WIDTH;
int HEIGHT;

float time;
float textureWeight;
 
#include "PTDataLib.cginc"

StructuredBuffer<ptRenderSettings> SETTINGS; 

//RWStructuredBuffer<Sphere> spheres;
//RWStructuredBuffer<Triangle> triangleMesh;
//RWStructuredBuffer<Mesh> meshesProper;
RWStructuredBuffer<ptObject> objects;

float intersect_sphere(ptObject sph, inout Ray r, inout float depth, inout ptHit a_hit)
{
	float3 pos = sph.transform._m03_m13_m23;

	float3 scale = float3(length(sph.transform._m00_m01_m02), length(sph.transform._m10_m11_m12), length(sph.transform._m20_m21_m22));
	float rad = length(scale) * 0.5f;
	rad = length(sph.transform._m00_m01_m02) / 2.0f;

	float3 op = pos - r.orig;    // distance from ray.orig to center sphere 
	float t;  // epsilon required to prevent floating point precision artefacts
	float b = dot(op, r.dir);    // b in quadratic equation
	float disc = b*b - dot(op, op) + rad*rad;  // discriminant quadratic equation
	if (disc<0) return 0;       // if disc < 0, no real solution (we're not interested in complex roots) 
	else disc = sqrt(disc);    // if disc >= 0, check for solutions using negative and positive discriminant
	depth = disc * 2.0f;
	
	float3 x = r.orig + r.dir*(b - disc);          // hitpoint 
	a_hit.normal = normalize(x - pos);

	//a_hit.normal = normalize(op);//normalize((pos + normalize(op) * disc) - pos);
	return (t = b - disc)>EPSILON ? t : ((t = b + disc)>EPSILON ? t : 0); // pick closest point in front of ray origin
}

float intersect_box(ptObject box, inout Ray r, inout float depth, inout ptHit a_hit)
{
	float3 pos = box.transform._m03_m13_m23;
	float3 bounds = float3(box.transform._m00, box.transform._m11, box.transform._m22);
	a_hit.normal = float3(0., 0., 0.);
	return 0.0f;
}

float intersect_plane(ptObject plane, inout Ray r, inout float t, inout ptHit a_hit)
{
	float3 pos = plane.transform._m03_m13_m23;
	float3 dim = float3(length(plane.transform._m00_m01_m02), length(plane.transform._m10_m11_m12), length(plane.transform._m20_m21_m22));
	
	float3 n = normalize(mul((plane.transform), float4(0., -1., 0., 0.)));
	float3 fwd = normalize(mul((plane.transform), float4(1, 0., 0., 0.)));
	float3 rgt = normalize(mul((plane.transform), float4(0., 0., 1, 0.)));
	float3 dd = dim;//mul((plane.transform), dim);//dim;// mul((plane.transform), float4(dim.x, dim.y, dim.z, 1.));//cross(dim, fwd); //mul((plane.transform), dim);
	//float3 dd = mul((plane.transform), float4(1., -0., 1., 1.));
	a_hit.normal = n;

	float denom = dot(n, r.dir); 
    if (denom > 1e-6) { 
        float3 p0l0 = pos - r.orig; 
        t = dot(p0l0, n) / denom; 
	

		float3 hpos = r.orig + r.dir * t; 
		float3 hdist = ((hpos - pos));
	
		float3 lhdist = mul(plane.invTransform, hdist);

		float ll = 5.0;
		float l1 = length(fwd) * 5;
		float l2 = length(rgt) * 5;

		//if(dot(n, fwd) < 0)
			//if(dot(n, rgt) < 0)
		//if(hpos.y > 1.0) 

		float s1 = dot(hdist, fwd);
		float s2 = dot(hdist, rgt);
	
		//if(s1 < l1 && s1 > -l1)
		//	if(s2 < l2 && s2 > -l2)
		if(lhdist.x > -ll && lhdist.x < ll)	
			//if(lhdist.y > -ll && lhdist.y < ll)	
				if(lhdist.z > -ll && lhdist.z < ll)	
		//if(hdist.x - 4 < dd.x && hdist.x + 6 > dd.x)
		//	if(hdist.y - 4 < dd.y && hdist.y + 6 > dd.y)
		//		if(hdist.z - 4 < dd.z && hdist.z + 6 > dd.z)
			//if(hdist.y - 4 < dim.y && hdist.y + 6 > dim.y)
				//if(hdist.z - 4 < dim.z && hdist.z + 6 > dim.z)
					return (t)>EPSILON ? t : ((t)>EPSILON ? t : 0); 
    } 

	return 0.0f;
}

bool intersect_scene(inout Ray r, inout float t, inout int id, inout float cdepth, inout ptHit a_hit) {

	float n = 6, d, inf = t = 1e20;  // t is distance to closest intersection, initialise t to a huge number outside scene
	float dd = 0.0f;


	uint numObjects, stride;
	objects.GetDimensions(numObjects, stride);
	ptHit tHit;
	for(int i = int(numObjects); i--;) {

		switch(objects[i].shapeType) 
		{
			// -- Box
			case 1:
			{
				if ((d = intersect_box(objects[i], r, dd, tHit)) && d < t) {  // if newly computed intersection distance d is smaller than current closest intersection distance
					t = d;  // keep track of distance along ray to closest intersection point 
					id = i; // and closest intersected object
					cdepth = dd;
					a_hit = tHit;
				}
			}
			break;

			// -- Plane
			case 2:
			{
				if ((d = intersect_plane(objects[i], r, dd, tHit)) && d < t) {  // if newly computed intersection distance d is smaller than current closest intersection distance
					t = d;  // keep track of distance along ray to closest intersection point 
					id = i; // and closest intersected object
					cdepth = dd;
					a_hit = tHit;

				}
			}
			break;

			default:
			{
				if ((d = intersect_sphere(objects[i], r, dd, tHit)) && d < t) {  // if newly computed intersection distance d is smaller than current closest intersection distance
					t = d;  // keep track of distance along ray to closest intersection point 
					id = i; // and closest intersected object
					cdepth = dd;
					a_hit = tHit;

					//float3 x = r.orig + r.dir*t;          // hitpoint 
					//a_hit.normal = normalize(x - objects[i].transform._m03_m13_m23); 

				}
			}
			break;
		}
	}

	

	return t<inf; // returns true if an intersection with the scene occurred, false when no hit
}

static float origRand(inout uint s0, inout uint s1) {
	//seed0 = 36969 * ((seed0+ asuint(time)) & 65535) + ((seed0+ asuint(time)) >> 16);  // hash the seeds using bitwise AND and bitshifts
	//seed1 = 18000 * ((seed1+ asuint(time)) & 65535) + ((seed1+ asuint(time)) >> 16);

	s0 = 36969 * ((s0 + asuint(textureWeight)) & 65535) + ((s0 + asuint(textureWeight)) >> 16);  // hash the seeds using bitwise AND and bitshifts
	s1 = 18000 * ((s1 + asuint(textureWeight)) & 65535) + ((s1 + asuint(textureWeight)) >> 16);

	uint ires = ((s0) << 16) + (s1);

	uint ui = (ires & 0x007fffff) | 0x40000000;  // bitwise AND, bitwise OR
	float uf = asfloat(ui);

	return (uf - 2.f) / 2.f;
}

static float rand(uint s0, uint s1){ 
	s0 = asuint((s0 * 12.9898));
	s1 = asuint((s1 * 78.233));
	return frac(sin(s0 + s1) * 43758.5453);
}

/*float noise(float2 p, float freq ){
	float unit = screenWidth/freq;
	float2 ij = floor(p/unit);
	float2 xy = mod(p,unit)/unit;
	//xy = 3.*xy*xy-2.*xy*xy*xy;
	xy = .5*(1.-cos(PI*xy));
	float a = rand((ij+vec2(0.,0.)));
	float b = rand((ij+vec2(1.,0.)));
	float c = rand((ij+vec2(0.,1.)));
	float d = rand((ij+vec2(1.,1.)));
	float x1 = mix(a, b, xy.x);
	float x2 = mix(c, d, xy.x);
	return mix(x1, x2, xy.y);
}*/

/*float pNoise(vec2 p, int res){
	float persistance = .5;
	float n = 0.;
	float normK = 0.;
	float f = 4.;
	float amp = 1.;
	int iCount = 0;
	for (int i = 0; i<50; i++){
		n+=amp*noise(p, f);
		f*=2.;
		normK+=amp;
		amp*=persistance;
		if (iCount == res) break;
		iCount++;
	}
	float nf = n/normK;
	return nf*nf*nf*nf;
}*/

static float getrandom(inout uint seed0, inout uint seed1) {
	return origRand(seed0, seed1);
	//return  rand(seed0, seed1);
} 

float3 radiance(Ray r2, inout uint s1, inout uint s2) { // returns ray color

	float3 accucolor = float3(0.0f, 0.0f, 0.0f); // accumulates ray colour with each iteration through bounce loop
	float3 mask = float3(1.0f, 1.0f, 1.0f);

	Ray r;
	r.orig = r2.orig;
	r.dir = r2.dir;	

	int MAXBOUNCE = SETTINGS[0].bounces;

	// ray bounce loop (no Russian Roulette used) 
	for (int bounces = 0; bounces < MAXBOUNCE; bounces++) {  // iteration up to 4 bounces (replaces recursion in CPU code)

		float t;           // distance to closest intersection 
		int id = 0;        // index of closest intersected sphere 

						   // test ray for intersection with scene
		float cdepth = 0.0f;
	
		ptHit sceneHit;

		if (!intersect_scene(r, t, id, cdepth, sceneHit)) {
			//accucolor += mask * float3(0.9,0.9,0.9);
			return accucolor;
		}

		ptObject obj = objects[id];  // hitobject

		float3 x = r.orig + r.dir*t;          // hitpoint 
		//float3 n = normalize(x - obj.transform._m03_m13_m23);    // normal
		float3 n = sceneHit.normal;
		float3 nl = dot(n, r.dir) < 0 ? n : n * -1; // front facing normal
		


		float3 L = -normalize(float3(1., -5., .2));

		int sid = 0;
		float scdepth = 0.0f, st = 0.0f;
		ptHit ssdepth;
		Ray sray = MakeRay(x + nl*EPSILON, L);

		accucolor += mask * obj.material.emission;// * ((dot(nl, L)) * 10.0);
		//mask *= float3(0.9,0.9,0.9);// * ((dot(nl, L)) * 10.0);
		//accucolor += mask * 100;// * ((dot(nl, L)) * 10.0);
			
		//if(bounces == 0)
			
			//mask *= max(0.f, dot(nl, L));


		
		// create 2 random numbers
		float r1 = 2 * M_PI * getrandom(s1, s2); // pick random number on unit circle (radius = 1, circumference = 2*Pi) for azimuth
		float r2 = getrandom(s1, s2);  // pick random number for elevation
		float r2s = sqrt(r2);
 
		// compute local orthonormal basis uvw at hitpoint to use for calculation random ray direction 
		// first vector = normal at hitpoint, second vector is orthogonal to first, third vector is orthogonal to first two vectors
		float3 w = nl;
		float3 u = normalize(cross((abs(w.x) > .1 ? float3(0, 1, 0) : float3(1, 0, 0)), w));
		float3 v = cross(w, u);

		// compute random ray direction on hemisphere using polar coordinates
		// cosine weighted importance sampling (favours ray directions closer to normal direction)
		float3 d = normalize(u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1 - r2));
		//d = lerp(d, reflDir, obj.material.metallic);
		float3 reflDir = reflect(r.dir, n);
		r.orig = x + nl*EPSILON;
		//r.dir = d;
		r.dir = lerp(d, reflDir, obj.material.metallic);
				

		mask *= obj.material.albedo;

		//mask.x *= obj.col.x;    
		mask *= dot(d, nl);  // weigh light contribution using cosine of angle between incident light and normal
		mask *= 1.5;          // fudge factor	
		
		//if(!intersect_scene(sray, st, sid, scdepth, ssdepth))
			//accucolor += mask * max(0.f, dot(nl, L));		
	}

	return accucolor;
}

inline float clamp(float x) { return x < 0.0f ? 0.0f : x > 1.0f ? 1.0f : x; }

inline int toInt(float x) { return int(pow(clamp(x), 1 / 2.2) * 255 + .5); }  // convert RGB float in range [0,1] to int in range [0, 255] and perform gamma correction

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	int ww = SETTINGS[0].outputWidth;
	int hh = SETTINGS[0].outputHeight;
	
	float2 resolution = float2 (ww, hh);
    float2 coordinates = float2 (id.x,id.y);
    float2 p = (coordinates.xy/resolution.xy);

	uint x = coordinates.x;
	uint y = coordinates.y;	

	uint i = (hh - y - 1)*ww + x; // index of current pixel (calculated using thread index) 

	uint s1 = x ;  // seeds for random number generator
	uint s2 = y ;

	float fov = camFOV * (M_PI / 180.0f);

	float2 co = p * 2.0 - 1.0;
	co.x *= (float)ww / (float)hh;

	float3 r = float3(0.0f, 0.0f, 0.0f); 

	float imgAspect = (float)ww / (float)hh;
	//float properFov = tan(camFOV / 2.0f * M_PI / 180.0f);
	float Px = (2.0f * ((x - 0.5) / ww) - 1) * imgAspect;
	float Py = (1.0f - 2.0f * ((y - 0.5) / hh) );

	float4 d = normalize(float4(Px, -Py, -1, 0));	

	float3 cop = camToWorld._m03_m13_m23;
	float3 cdp = normalize(mul(camToWorld, d).xyz).xyz;

	for (int s = 0; s < SETTINGS[0].samples; s++) { 
		r = r + radiance(MakeRay(cop, cdp), s1, s2)*(1. / SETTINGS[0].samples);
	}

	//float4 outt = float4(clamp(r.x, 0.0f, 1.0f), clamp(r.y, 0.0f, 1.0f), clamp(r.z, 0.0f, 1.0f), 1.0);
	float4 outt = float4(r.x, r.y, r.z, 1.0);
	
	//float v = ((r.x + r.y + r.z) / 3.0);

	Result[id.xy] = lerp(outt, Input[id.xy], textureWeight);
}
